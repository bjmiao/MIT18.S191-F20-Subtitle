1
00:00:00,080 --> 00:00:03,818
大家好，我是艾伦·埃德曼

2
00:00:03,879 --> 00:00:07,659
这个短视频是关于数组的基础知识的

3
00:00:07,759 --> 00:00:10,213
所以如果你想定义一个向量，你可以用

4
00:00:10,238 --> 00:00:13,100
v = [1,2,3,4]

5
00:00:13,199 --> 00:00:15,794
可以看到v的大小是(4,)
注：注意这和(4,1)的Array不同。

6
00:00:16,083 --> 00:00:18,296
但是，如果要声明一个数组，一种方法是写

7
00:00:18,320 --> 00:00:20,694
a = [1 2 3
      4 5 6]

8
00:00:20,719 --> 00:00:23,363
一个方括号在上一行，另一个在下一行

9
00:00:23,840 --> 00:00:27,538
w的大小是(2,3) （注：指两行，三列）

10
00:00:27,567 --> 00:00:30,139
接下来我展示一些简单的数组操作

11
00:00:30,239 --> 00:00:32,487
如果要让左上角元素

12
00:00:32,511 --> 00:00:35,243
输入w[1,1]，得到结果为1

13
00:00:35,254 --> 00:00:38,315
如果想取右下角的元素

14
00:00:38,564 --> 00:00:42,419
是第二行的第三个数，w[2,3]，结果得到6

15
00:00:42,443 --> 00:00:44,458
如果想要取整个第一行

16
00:00:44,558 --> 00:00:49,579
你可以写w[1,:]，这就是在取
整个第一行

17
00:00:49,679 --> 00:00:51,975
结果会以一个向量返回

18
00:00:51,999 --> 00:00:56,938
或者也可以取整个第一列,w[:, 1]，结果也将作为向量返回

19
00:00:57,039 --> 00:00:59,819
 向量是一维的

20
00:00:59,920 --> 00:01:01,899
而不是n * 1或者1 * n的

21
00:01:02,000 --> 00:01:05,205
它是一个Julia中的一维物体

22
00:01:05,230 --> 00:01:07,476
你也可以沿着某些维度做切片（Slice）操作

23
00:01:07,501 --> 00:01:09,259
所以你可以写

24
00:01:09,359 --> 00:01:11,819
w[:, 2:3]，沿着第二个维度做切片

25
00:01:11,920 --> 00:01:14,937
结果将得到一个二乘二的数组

26
00:01:14,961 --> 00:01:16,859
所以现在让我们声明一些有趣的数组

27
00:01:16,959 --> 00:01:20,219
这是一个包含随机元素的矩阵

28
00:01:20,319 --> 00:01:22,059
元素会从1到9整数中均匀选择

29
00:01:22,159 --> 00:01:23,899
这是个3行4列的矩阵

30
00:01:24,000 --> 00:01:27,100
因此，如果我多执行几次

31
00:01:27,200 --> 00:01:29,419
可以看到我会得到不同元素的矩阵

32
00:01:29,519 --> 00:01:32,139
但A1数组的大小永远是(3, 4)

33
00:01:32,239 --> 00:01:36,838
接下来看这里，这里出现了一些随机的漂亮字符

34
00:01:36,863 --> 00:01:38,619
它们看起来很有趣吧 O(∩_∩)O

35
00:01:38,719 --> 00:01:42,219
如果我不使用最后的pretty函数

36
00:01:42,319 --> 00:01:44,219
（这个函数就在下面一个代码块里写着）

37
00:01:44,319 --> 00:01:46,059
你会看到打印出来的东西就不太好看

38
00:01:46,159 --> 00:01:47,419
的确，虽然没很糟糕

39
00:01:47,519 --> 00:01:50,539
但是这些引号看起来就很累赘

40
00:01:50,640 --> 00:01:52,883
pretty函数使它看起来更紧凑，也更好看

41
00:01:52,908 --> 00:01:54,779
我们运行几次，看看结果长这样

42
00:01:54,879 --> 00:01:56,378
所以我们做的实际上是

43
00:01:56,478 --> 00:01:59,179
将每个字符都转换为字符串

44
00:01:59,280 --> 00:02:01,346
然后把它们连起来,最终得到这个好看的显示方式

45
00:02:01,370 --> 00:02:05,658
我自己是看不懂这坨神奇代码的，它是你们的一位TA

46
00:02:05,759 --> 00:02:08,938
之前为了让结果看起来更棒而写的

47
00:02:09,038 --> 00:02:12,460
不过我也不操心这个 ⊙▽⊙

48
00:02:12,577 --> 00:02:15,028
下一个例子：这是一些可区分颜色的100种颜色

49
00:02:15,053 --> 00:02:16,859
噢，或者让我们一步步来

50
00:02:16,950 --> 00:02:19,266
我们先选择三种可区分的颜色

51
00:02:19,291 --> 00:02:21,430
画面上就显示了三种不同的，很有区分度的颜色

52
00:02:21,455 --> 00:02:25,340
参数改成6，就有了六种颜色。所以这其实就是生成了集中对比度强的颜色

53
00:02:25,439 --> 00:02:28,380
对普通人的眼睛来说很有区分度

54
00:02:28,479 --> 00:02:30,828
当然，是指对普通人的眼睛

55
00:02:31,003 --> 00:02:32,928
所以，我们知道，用这些颜色来生成一张图

56
00:02:32,953 --> 00:02:35,014
或者做一些其他的事情

57
00:02:35,113 --> 00:02:37,174
会让这些图中的颜色很容易显出不同

58
00:02:37,274 --> 00:02:39,494
这是一堆可区分的颜色

59
00:02:39,594 --> 00:02:41,790
而这边下面随机生成了

60
00:02:41,917 --> 00:02:44,425
10 x 10的数组，每个元素都用上面这些颜色填满

61
00:02:44,553 --> 00:02:47,974
所以每次运行时，我都能得到不同的一组组10 x 10的随机颜色

62
00:02:48,073 --> 00:02:49,494
好的，再来看下一个例子

63
00:02:49,594 --> 00:02:51,094
我刚刚下载了一张柯基的图片

64
00:02:51,194 --> 00:02:53,254
是从某个网页上下载下来的的

65
00:02:53,353 --> 00:02:55,094
另外我下载了一个史努比的图片

66
00:02:55,194 --> 00:02:56,614
所以在这里你可以看到我

67
00:02:56,714 --> 00:02:58,854
可以生成一个随机的5x5数组

68
00:02:58,953 --> 00:03:00,934
数组都是由柯基和史努比的图片组成

69
00:03:01,034 --> 00:03:02,374
当我每次我运行代码时

70
00:03:02,474 --> 00:03:04,934
虽然代码执行需要一些事件

71
00:03:05,034 --> 00:03:06,614
不过可以看到，每次我都能看到一个不同的

72
00:03:06,714 --> 00:03:09,014
由柯基和史努比组成的数组

73
00:03:09,113 --> 00:03:12,934
好的，让我们来看接下来的一点代码

74
00:03:13,034 --> 00:03:16,053
首先，图中的这一段代码

75
00:03:16,153 --> 00:03:21,094
可以让我复制出一个和A1相同的，由一堆数组组成的数组

76
00:03:21,194 --> 00:03:23,928
然后在左上角的元素中写入123

77
00:03:23,953 --> 00:03:26,294
或类似地

78
00:03:26,393 --> 00:03:29,301
我可以在这里用史努比的图片填充一个5x5的数组

79
00:03:29,326 --> 00:03:31,759
并在左上方的元素中放置一只柯基犬

80
00:03:31,783 --> 00:03:33,894
下一个例子：这边是一张乘法表

81
00:03:33,919 --> 00:03:39,014
这在Julia和一些类似的语言中被称为“列表递推式”

82
00:03:39,113 --> 00:03:42,693
它看起来有点像数学的集合符号，我们有i*j

83
00:03:42,792 --> 00:03:46,534
其中i和j都从1-5遍历。这就是列表递推式，可以生成一个数组

84
00:03:46,633 --> 00:03:49,894
当然，你可以用一个包含两个循环变量的double for循环来完成这个操作

85
00:03:49,994 --> 00:03:51,494
但是它看起来就更笨重一点

86
00:03:51,519 --> 00:03:53,890
因此人们在方便的时候，会更倾向于使用列表递推式

87
00:03:53,914 --> 00:03:56,949
甚至，你也可以像其他的编程语言一样，用双层嵌套的for循环来完成这件事

88
00:03:56,974 --> 00:03:58,693
确实，嵌套循环也是可以用的

89
00:03:58,792 --> 00:04:01,375
但，列表递推式真的是更好的选择

90
00:04:01,577 --> 00:04:04,586
人们也更倾向于用它

91
00:04:04,611 --> 00:04:06,213
接下来看下一个例子：如果你只是对一个数组求平方(A^2)

92
00:04:06,238 --> 00:04:11,333
你得到矩阵乘以本身

93
00:04:11,433 --> 00:04:14,693
不过如果你用"点平方" (A.^2)

94
00:04:14,792 --> 00:04:18,134
你会得到每个元素求平方之后的结果

95
00:04:18,233 --> 00:04:20,453
您也可以通过将矩阵放在方括号中并排

96
00:04:20,553 --> 00:04:22,773
来拼接它们

97
00:04:22,873 --> 00:04:28,544
所以如果写[A4 A4]，那么就会把A4的列数增加一倍

98
00:04:28,569 --> 00:04:31,935
当然，你还可以用分号将数组在垂直方向上拼接

99
00:04:31,960 --> 00:04:35,984
所以如果写[A3;A3], 就会得到如图所示的结果
A3在垂直方向重复出现了两次

100
00:04:36,166 --> 00:04:39,857
你当然可以同时使用水平拼接和数值拼接

101
00:04:40,293 --> 00:04:44,694
如图所示，就是这样

102
00:04:44,785 --> 00:04:50,453
好的，以上就是基本的一些矩阵操作，谢谢大家！

