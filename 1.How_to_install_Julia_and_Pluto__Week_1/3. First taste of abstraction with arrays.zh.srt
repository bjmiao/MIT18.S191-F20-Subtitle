1
00:00:00,240 --> 00:00:02,119
我是Alan Edelman，我身后的是小柯基菲利普

2
00:00:02,144 --> 00:00:04,733
今天我们来谈谈关于“抽象”（abstraction）的概念

3
00:00:05,333 --> 00:00:08,206
抽象有一个反义词：特例化（Specialization）

4
00:00:08,800 --> 00:00:12,293
这两个词都是关于“什么东西相同”和“什么东西不同”

5
00:00:12,318 --> 00:00:15,412
比如说东西的不同，或者东西类型的不同
（友情提示：这个Lecture比较玄学，不懂的话可以跳过）

6
00:00:16,182 --> 00:00:20,440
所以，让我们开始吧！

7
00:00:20,640 --> 00:00:23,480
声明一个变量，比如说叫element

8
00:00:23,679 --> 00:00:26,919
然后我们让它等于，比如说，1

9
00:00:27,118 --> 00:00:30,839
然后，我们把这个变量element放到一个数组中

10
00:00:31,039 --> 00:00:39,324
比如说，我们可以用这个变量填满一个三行四列的二维数组

11
00:00:39,555 --> 00:00:44,038
好了，现在就可以在屏幕上看到这个3*4的，每个元素都是1的数组了

12
00:00:44,238 --> 00:00:47,414
让我们仔细看看Julia返回的信息

13
00:00:47,439 --> 00:00:49,320
她显示：这是个3*4的数组(3x4 Array)

14
00:00:49,520 --> 00:00:51,653
数字2表示这是数组是二维的

15
00:00:51,678 --> 00:00:54,564
如果这里是1就表示向量，2的话就是一个矩阵

16
00:00:54,588 --> 00:00:58,439
如果是3的话一般会被叫做一个张量（Tensor）或者就叫三维数组

17
00:00:58,640 --> 00:01:01,143
而Int64表示每个元素都是64位整数

18
00:01:01,620 --> 00:01:07,643
说明一下，如果我是用Julia指令“typeof”，来查看变量element的类型

19
00:01:07,897 --> 00:01:10,461
结果会显示，element是一个64位整数的
（什么是64位整数可以自行百度）

20
00:01:10,834 --> 00:01:13,087
现在我们继续， 做一些别的尝试

21
00:01:13,112 --> 00:01:17,238
例如，我们可以把变量element变为 1.0

22
00:01:17,438 --> 00:01:20,840
好，现在看，我有一个3x4的数组

23
00:01:21,031 --> 00:01:22,955
而每个数组元素都是浮点数，64位的

24
00:01:22,989 --> 00:01:25,194
我们可以看到，1.0是个浮点类型的数

25
00:01:25,249 --> 00:01:28,599
fill的结果仍然是个二维数组，但是每个元素成了浮点数

26
00:01:28,799 --> 00:01:32,519
也许我们应该记录下

27
00:01:32,719 --> 00:01:36,439
整个过程我们输入过的数字

28
00:01:36,640 --> 00:01:39,655
或者说，我们至少记录下每次element的变量类型

29
00:01:39,680 --> 00:01:43,079
所以一开始是typeof(1)，然后是typeof(1.0)

30
00:01:43,280 --> 00:01:47,000
让我们把这些变量类型放入数组中

31
00:01:47,316 --> 00:01:48,808
我们可以看到...

32
00:01:48,990 --> 00:01:52,149
... Oh，我需要打个逗号才能让它成为一个向量

33
00:01:52,719 --> 00:01:56,039
OK，你可以在这里看到

34
00:01:56,239 --> 00:01:59,558
我们有一个Int64和一个Float64

35
00:01:59,759 --> 00:02:02,658
如果你想知道keeptrack这个数组本身的类型是什么

36
00:02:02,879 --> 00:02:05,103
它的类型的确和别的东西略有不同

37
00:02:05,230 --> 00:02:07,443
你可以看到，在julia内部表示中

38
00:02:07,468 --> 00:02:09,880
它是一个数组，它是一维的

39
00:02:10,142 --> 00:02:12,904
每个元素的类型是"数据类型(DataType)"

40
00:02:12,929 --> 00:02:14,600
所以让我们继续做别的尝试

41
00:02:14,792 --> 00:02:16,773
并将元素更改为字符串

42
00:02:17,074 --> 00:02:19,447
我们把element设置为的字符串"one"

43
00:02:19,487 --> 00:02:24,335
oh 看来我的小助教（小柯基）有点别的事要离开了

44
00:02:24,360 --> 00:02:30,439
好的，我们在下面（第三个代码块）中显示了element的类型
它的类型是一个字符串

45
00:02:30,639 --> 00:02:34,929
我们有一个3*4的由字符串“one”构成的数组

46
00:02:35,072 --> 00:02:37,640
因此，我们也将其添加到keeptrack向量中

47
00:02:37,840 --> 00:02:39,800
以便跟踪

48
00:02:39,825 --> 00:02:44,182
看，我们有整数(Int64)

49
00:02:44,207 --> 00:02:45,723
(...)

50
00:02:45,775 --> 00:02:48,310
我们有浮点数(Float64)，也有字符串(String)

51
00:02:48,516 --> 00:02:51,974
在这里，我们想表达的主要观点是
（敲黑板，知识点来了）

52
00:02:52,479 --> 00:02:57,290
一种编程语言，不应该让这些数据类型直接有任何的区别
（C语言：表示有被冒犯到）

53
00:02:57,520 --> 00:03:00,981
我再展示另一个数据类型：有理数

54
00:03:01,598 --> 00:03:05,480
Julia里面，可以用两个斜杠 (比如1 // 1)来表示有理数

55
00:03:05,680 --> 00:03:08,920
这个有理数是现在的矩阵元素，它构成了一个3x4矩阵

56
00:03:09,120 --> 00:03:10,840
这就很有趣了朋友们

57
00:03:11,039 --> 00:03:13,573
这边Datatype的第二个数仍然是2，代表是个二维数组

58
00:03:13,598 --> 00:03:15,815
但是它元素类型成了有理数（Rational）

59
00:03:15,848 --> 00:03:18,047
而这个有理数又是由64位整数组成的
（注：也就是指分子分母都是64位整数）

60
00:03:18,239 --> 00:03:21,080
这是一个由“别的类型”组成的数据类型

61
00:03:21,280 --> 00:03:22,726
如果愿意的话可以叫它"复合类型"

62
00:03:22,909 --> 00:03:25,880
即，由64位整数组成的有理数

63
00:03:26,080 --> 00:03:28,360
好吧，让我们也把它放在keeptrack这里

64
00:03:28,560 --> 00:03:33,480
在变量中输入typeof(1//1)即可

65
00:03:33,680 --> 00:03:36,646
好，所以我们现在就有整数，浮点数，字符串和有理数

66
00:03:36,671 --> 00:03:40,447
来，让我来跳脱出来正在做的事，并且告诉你重点

67
00:03:40,782 --> 00:03:43,719
某种程度上，对人类来说，这些东西都是1

68
00:03:43,919 --> 00:03:45,655
以不同的形式表示的“1”

69
00:03:45,680 --> 00:03:48,401
有整数1，浮点数1.0，字符串"one"

70
00:03:48,679 --> 00:03:50,272
有理数 1//1

71
00:03:50,351 --> 00:03:55,319
你可能还想到别的人类语言中的“1”，例如西班牙的Uno

72
00:03:55,519 --> 00:04:00,439
或者汉字当中的“一”，啊对我来说看起来像一个长划号（Dash，“-”）

73
00:04:00,639 --> 00:04:05,959
好，所有的这些，都是1的“抽象化”的概念的表示

74
00:04:06,158 --> 00:04:07,941
当然，在电脑中

75
00:04:08,250 --> 00:04:12,759
具体来说，这些“1”都以不同的方式表示

76
00:04:12,784 --> 00:04:14,280
即使我们人为可以认为这些都是1

77
00:04:14,479 --> 00:04:16,797
我们可以做些更厉害的事

78
00:04:16,932 --> 00:04:20,883
我们可以去找一张1的图片

79
00:04:20,908 --> 00:04:23,960
其中一个看起来很不错哦，这很有趣

80
00:04:24,160 --> 00:04:25,708
这是一个可爱的数字

81
00:04:25,804 --> 00:04:31,667
使用download加上网址，来下载图片

82
00:04:31,692 --> 00:04:34,659
这串URL复制过来即可

83
00:04:34,684 --> 00:04:39,553
（这里教授应该是在导入Images包的时候遇到了问题 ）
（如果Images包没有安装，那么要加前两行添加这个包）

84
00:04:39,578 --> 00:04:44,199
（如果Images包已经安装好了，那么就不用前两行）
（因此教授要把它们注释掉）

85
00:04:44,399 --> 00:04:48,520
好，我们需要载入Images包来使用load函数，而现在终于有了

86
00:04:48,720 --> 00:04:51,160
好的，那现在这个应该能运行了

87
00:04:51,360 --> 00:04:54,278
这里有一个“1”的小图片，喜欢吗？

88
00:04:54,478 --> 00:04:57,960
好吧，让我们... 等一下

89
00:04:58,160 --> 00:05:02,120
嗯，我们应该怎么称呼它呢？

90
00:05:02,319 --> 00:05:05,319
叫cute_one怎么样？

91
00:05:05,519 --> 00:05:08,999
这是一个可爱的1的图片，储存在了名叫cute_one的变量里

92
00:05:09,199 --> 00:05:11,800
所以现在我们可以做的是

93
00:05:12,000 --> 00:05:14,480
有趣的事来了

94
00:05:14,505 --> 00:05:17,559
把数组元素设置为cute_one

95
00:05:17,759 --> 00:05:22,759
你可以看到我们现在有一个3*4的，由图像构成的数组

96
00:05:22,959 --> 00:05:26,759
很不错吧？你现在可以看到

97
00:05:26,959 --> 00:05:29,400
只需更改数组元素的类型

98
00:05:29,600 --> 00:05:33,240
做一个很像（但是不完全相同）的事情

99
00:05:33,439 --> 00:05:37,636
想像一下，如果数组的元素本身就是一个数组

100
00:05:37,661 --> 00:05:43,603
比如说，我的元素是数组[1 2; 3,4]

101
00:05:43,628 --> 00:05:45,205
好，来看看发生了啥

102
00:05:45,530 --> 00:05:49,585
我们来研究一下这个东西。数组的变量，element，是[1 2; 3 4]的二维数组

103
00:05:49,610 --> 00:05:52,838
所以现在，我们有一个由数组组成的数组

104
00:05:53,038 --> 00:05:55,960
你可以看到，这边的嵌套其实是很合理的

105
00:05:56,160 --> 00:05:58,695
外层是一个二维的数组，

106
00:05:58,720 --> 00:06:02,520
内层的Array{Int64,2}代表，每个元素又是一个二维数组

107
00:06:02,545 --> 00:06:06,046
这些个内层数组是由64位整数（Int64）组成的

108
00:06:06,435 --> 00:06:10,520
这里的格式很紧凑，你可能很喜欢，也可能觉得很凌乱

109
00:06:10,697 --> 00:06:15,403
但是你可以看到，这里每个元素的类型是64位整数
（即typeof(element)的结果）

110
00:06:15,499 --> 00:06:17,254
看起来很有道理的样子

111
00:06:17,279 --> 00:06:21,360
实际上也可以把新的这些元素类型放到keeptrack里

112
00:06:21,385 --> 00:06:26,044
我们可以在向量里面填上typeof([1 2; 3 4])

113
00:06:26,282 --> 00:06:27,567
你可以看到

114
00:06:28,353 --> 00:06:33,400
现在的元素的数据类型变成了数组

115
00:06:33,600 --> 00:06:36,759
好吧，让我们走得更远，生成一个数组

116
00:06:36,959 --> 00:06:41,718
元素是cute_one（刚刚下载下来的图片）

117
00:06:42,060 --> 00:06:44,353
让它作为数组的元素

118
00:06:44,519 --> 00:06:50,199
让我们来仔细研究一下，这个图像被复制成了一个3行4列的大图

119
00:06:50,399 --> 00:06:53,900
让我们看一下这个数组元素（也就是这张图片）的数据类型

120
00:06:53,925 --> 00:06:56,838
它本身是一个数组，由颜色组成的数组

121
00:06:57,038 --> 00:07:01,921
所以直观来说，什么是图片？

122
00:07:01,946 --> 00:07:05,160
一张图片，就是一个由颜色组成的数组

123
00:07:05,360 --> 00:07:08,520
最终的结果（fill函数的结果）是一个“颜色的数组的数组”

124
00:07:08,720 --> 00:07:12,199
对了，颜色本身就是一种复合数据类型

125
00:07:12,399 --> 00:07:16,711
它是RGBA，红色绿色蓝色和阿尔法值（Alpha），Alpha代表了透明度

126
00:07:16,736 --> 00:07:21,537
每一个分量都是一个无符号整数，用一些方式正则化了（Normed）

127
00:07:21,562 --> 00:07:25,003
所以我想总结一下

128
00:07:25,028 --> 00:07:28,831
什么是数组？数组其实就是一个容器

129
00:07:28,863 --> 00:07:31,322
是一个包含了很多元素的容器

130
00:07:31,347 --> 00:07:33,800
元素可以是许多不同的类型

131
00:07:34,000 --> 00:07:38,073
很快我们将看到，我们可以编写作用在数组上的函数

132
00:07:38,359 --> 00:07:40,772
如果函数设计和编写得当，

133
00:07:40,915 --> 00:07:43,786
这些函数应该与数据的内部类型无关的

134
00:07:43,811 --> 00:07:45,814
换句话说，如果你想移动数组元素

135
00:07:45,839 --> 00:07:48,054
或者你想操作一个数组

136
00:07:48,079 --> 00:07:50,832
它不应该关心这个数组的元素是什么类型的

137
00:07:50,857 --> 00:07:52,452
只要元素的类型有意义

138
00:07:52,477 --> 00:07:59,079
讲完了，现在你应该对"抽象"这个概念有了一定认识

