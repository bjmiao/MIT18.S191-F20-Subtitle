1
00:00:01,030 --> 00:00:02,530
这门课程的前几周

2
00:00:02,530 --> 00:00:05,020
将讨论图像处理的话题

3
00:00:05,020 --> 00:00:06,400
所以第一节课

4
00:00:06,400 --> 00:00:08,315
我想要做的就是通过Julia语言

5
00:00:08,315 --> 00:00:10,826
介绍一些处理图像的基础知识

6
00:00:11,155 --> 00:00:14,431
现在屏幕上显示的并不是普通的PPT

7
00:00:14,431 --> 00:00:16,506
而是叫做Pluto的一种笔记本（注：第一节课提到过）

8
00:00:16,616 --> 00:00:18,300
所以在Pluto中，

9
00:00:18,300 --> 00:00:23,130
你可以任意输入Julia代码，然后它会立刻显示该代码的输出

10
00:00:23,310 --> 00:00:25,560
用这种方法处理图像将会十分方便

11
00:00:25,560 --> 00:00:26,880
事实上，在听课过程中

12
00:00:26,880 --> 00:00:28,466
如果你愿意，你可以跟着我们一起敲代码

13
00:00:28,466 --> 00:00:30,649
事实上只要敲一样的代码，或者

14
00:00:30,649 --> 00:00:33,420
简单修改一些输入或者参数，就亲身体验代码效果

15
00:00:33,600 --> 00:00:36,150
我们可以使用Pluto笔记本做一些有趣的事情

16
00:00:36,150 --> 00:00:40,230
像在这里嵌入一个小摄像头

17
00:00:40,230 --> 00:00:42,670
这样我就可以拍摄图片

18
00:00:42,850 --> 00:00:46,830
然后可以将该图片的输出用作程序变量

19
00:00:47,010 --> 00:00:48,090
比如，在这个代码块里面

20
00:00:48,090 --> 00:00:50,592
我们声明变量grant，并把他作为

21
00:00:50,592 --> 00:00:53,595
摄像头抓拍获取的照片

22
00:00:53,595 --> 00:00:55,752
并将其视为程序的变量

23
00:00:55,939 --> 00:00:58,650
在第一周的作业里，你要完成的一个任务

24
00:00:58,650 --> 00:01:02,670
就是编写一个函数，来检测图像中的边缘，很酷吧~

25
00:01:02,670 --> 00:01:03,630
所以你可以放自己喜欢的照片

26
00:01:03,630 --> 00:01:06,720
程序将在该图片中检测出边缘的分布

27
00:01:06,830 --> 00:01:09,250
这在许多科学应用中都非常有用

28
00:01:09,430 --> 00:01:09,940
但在那之前

29
00:01:09,940 --> 00:01:14,440
让我们复习一下，图像到底是什么？

30
00:01:14,620 --> 00:01:16,990
在计算机中处理图像时

31
00:01:16,990 --> 00:01:19,330
我猜你们当中很多人对此很熟悉

32
00:01:19,330 --> 00:01:21,250
它本质上是很多格点，每个格点叫做一个像素

33
00:01:21,250 --> 00:01:26,020
因此，让我们来一张我们家猫带着领结的照片

34
00:01:26,020 --> 00:01:28,140
……别问我问什么是我们家猫 :)

35
00:01:28,620 --> 00:01:29,940
如果我们仔细观察这张照片

36
00:01:30,130 --> 00:01:31,580
并且放大了看

37
00:01:31,760 --> 00:01:35,420
比如可以放大到这双黄褐色，仔细观察

38
00:01:35,600 --> 00:01:38,450
很好，你会发现图上面看到的都是一个个小方块

39
00:01:38,450 --> 00:01:40,490
每个方块都是单色

40
00:01:40,490 --> 00:01:41,660
所以在计算机表示中，

41
00:01:41,660 --> 00:01:45,590
它将每个小方块表示为用于一个特定的数据类型

42
00:01:45,590 --> 00:01:46,880
一次来表示一种颜色

43
00:01:46,880 --> 00:01:48,710
然后构建一个巨大的颜色网格

44
00:01:48,710 --> 00:01:52,419
顺便说一句，我们习惯上会从图片的左上角开始对这些像素进行编号

45
00:01:52,419 --> 00:01:53,300
所以举个例子

46
00:01:53,300 --> 00:01:55,610
第一个下标告诉我们要往下数多少格

47
00:01:55,610 --> 00:01:59,930
在第二个索引告诉我们要往下数几个格点

48
00:02:00,300 --> 00:02:01,950
所以让我们开始用Julia来处理图片吧

49
00:02:01,950 --> 00:02:04,180
我们会在过程中处理一些真实的图片

50
00:02:04,360 --> 00:02:06,130
在这里有一个图片网站

51
00:02:06,130 --> 00:02:07,780
我们可以从网站上下载图像

52
00:02:07,780 --> 00:02:09,520
所以我定义了一个变量'url'

53
00:02:09,520 --> 00:02:11,080
这是一个字符串

54
00:02:11,080 --> 00:02:12,970
和其他编程语言一样

55
00:02:12,970 --> 00:02:15,074
我们使用双引号来表示字符串

56
00:02:15,098 --> 00:02:16,900
它将提取特定的图像

57
00:02:16,900 --> 00:02:19,460
这将是Philip，一只小柯基犬

58
00:02:19,640 --> 00:02:22,280
下一行代码里会下载这个url中的任何内容

59
00:02:22,280 --> 00:02:24,410
并保存到本地

60
00:02:24,410 --> 00:02:26,860
命名为philip.jpg

61
00:02:27,140 --> 00:02:28,370
然后在下一个代码块中

62
00:02:28,370 --> 00:02:31,220
我将开始使用图像库Images

63
00:02:31,220 --> 00:02:36,030
在Julia中，导入某个库，并且使用库里的函数，用的是using

64
00:02:36,210 --> 00:02:41,220
然后我可以声明philip的变量，让它等于load(...)

65
00:02:41,220 --> 00:02:45,190
括号里面是该文件的路径，这个文件已经被保存在系统本地

66
00:02:45,370 --> 00:02:49,160
注意：如果在Pluto中的一个代码块有多行的内容

67
00:02:49,340 --> 00:02:51,978
我们需要用begin-end把它包裹起来，作为一整个代码块

68
00:02:51,978 --> 00:02:54,810
我们需要用begin-end把它包裹起来，作为一整个代码块

69
00:02:54,810 --> 00:02:55,860
现在，当我运行这条语句

70
00:02:56,120 --> 00:02:59,150
它会显示代码块最后一行语句中的返回结果

71
00:02:59,150 --> 00:03:03,580
在这种情况下，它将显示Philip这张图片本身

72
00:03:03,890 --> 00:03:04,757
看起来很棒！

73
00:03:04,757 --> 00:03:08,580
Pluto笔记本可以猜到，像Philip这样的对象

74
00:03:08,580 --> 00:03:11,204
很可能是一张图片，所以它并不显示它的原始数据

75
00:03:11,204 --> 00:03:13,970
而是会显示这张图片本身

76
00:03:14,150 --> 00:03:17,630
但实际上我们可能想更深入了解这张图片

77
00:03:17,630 --> 00:03:19,640
了解原始数据中的一些特性

78
00:03:19,640 --> 00:03:22,650
所以我可以输入"typeof(philip)"

79
00:03:23,530 --> 00:03:25,820
结果返回了一个变量类型

80
00:03:26,300 --> 00:03:28,340
乍一看可能比较令人头疼

81
00:03:28,340 --> 00:03:29,360
乍一看可能比较令人头疼

82
00:03:29,360 --> 00:03:34,060
但是其实它是在告诉我们这个变量是一个数组

83
00:03:34,240 --> 00:03:36,700
这里的2代表这是个二维数组

84
00:03:36,700 --> 00:03:39,543
因此，一维数组将只是一列数据

85
00:03:39,567 --> 00:03:42,330
而二维数组则是“一个网格”的数据

86
00:03:42,510 --> 00:03:46,080
然后每个值的类型是这边的RGBX

87
00:03:46,080 --> 00:03:48,630
RGB代表红色，绿色，蓝色

88
00:03:48,630 --> 00:03:52,350
这是描述计算机颜色的非常标准的方法

89
00:03:52,350 --> 00:03:53,682
用三个数来表述这个颜色

90
00:03:53,682 --> 00:03:56,280
代表有多红，多绿，多蓝

91
00:03:56,280 --> 00:03:58,100
如果你想知道X代表什么

92
00:03:58,100 --> 00:03:59,840
我觉得目前还不需要了解到那么细节

93
00:03:59,840 --> 00:04:01,251
它只是一种填充

94
00:04:01,379 --> 00:04:03,871
可以让原始数据的表示更加美观

95
00:04:03,871 --> 00:04:06,070
但是如果你探究这种变量类型

96
00:04:06,070 --> 00:04:11,472
你可以输入RGBX，然后输入随便几个值

97
00:04:11,591 --> 00:04:13,333
分别代表红色，绿色和蓝色

98
00:04:13,333 --> 00:04:15,910
它们都处在0和1之间

99
00:04:15,910 --> 00:04:17,410
输入完以后

100
00:04:17,410 --> 00:04:20,980
它实际上给了我这个RGB值对应的颜色

101
00:04:20,980 --> 00:04:23,410
如果我增加G部分

102
00:04:23,410 --> 00:04:25,450
也就是绿色部分

103
00:04:25,450 --> 00:04:27,130
我得到了更绿的颜色

104
00:04:27,130 --> 00:04:28,420
但是如果我增加红色部分

105
00:04:28,420 --> 00:04:28,630
没错

106
00:04:28,630 --> 00:04:32,350
我会在这里得到更红的图像，在这里红色和绿色混合

107
00:04:32,350 --> 00:04:33,430
如果我把另两种颜色值降低

108
00:04:33,430 --> 00:04:33,640
是的

109
00:04:33,640 --> 00:04:35,250
我们看到非常红的颜色

110
00:04:35,440 --> 00:04:36,280
看得出是个很简单的类型

111
00:04:36,280 --> 00:04:40,510
我们前面的变量philip就是一系列的颜色变量

112
00:04:40,510 --> 00:04:42,080
没错，一张图片就是一堆颜色

113
00:04:42,260 --> 00:04:44,620
我们也可以获取Philip的大小

114
00:04:44,800 --> 00:04:46,660
程序会给我们维度

115
00:04:46,660 --> 00:04:51,860
在这里，程序告诉我们大小是3675*2988

116
00:04:52,070 --> 00:04:53,630
也许你会好奇哪个数代表高度

117
00:04:53,630 --> 00:04:55,020
哪一个是宽度

118
00:04:55,200 --> 00:04:58,413
我们看一下philip图片本身就知道了

119
00:04:58,437 --> 00:05:01,650
注意到这是一张高度比宽度要大得多的图像

120
00:05:01,650 --> 00:05:04,650
因此说明，第一个变量正在代表图像高度

121
00:05:04,650 --> 00:05:06,600
第二个代表图像宽度

122
00:05:06,600 --> 00:05:08,280
是真的

123
00:05:08,590 --> 00:05:11,830
我们也可以直接用下标来索引该数组中

124
00:05:11,830 --> 00:05:13,420
所以如果我输入"philip[...]"

125
00:05:13,420 --> 00:05:15,060
然后下标里面索引

126
00:05:15,250 --> 00:05:18,310
从上向下的第100个像素

127
00:05:18,310 --> 00:05:22,070
然后从左起第400个像素

128
00:05:22,250 --> 00:05:25,906
它会为我们返回RGB类型的东西

129
00:05:25,906 --> 00:05:29,200
所以如果我继续输出返回结果的类型

130
00:05:29,200 --> 00:05:30,700
它是个RGB对象

131
00:05:30,700 --> 00:05:32,980
但是当Pluto笔记本获取输入时

132
00:05:32,980 --> 00:05:34,960
它认为我们想要看的颜色本身而不是原始数值

133
00:05:34,960 --> 00:05:36,840
很多情况下对我们来说很方便

134
00:05:37,020 --> 00:05:37,560
因此

135
00:05:37,560 --> 00:05:40,470
我们刚刚从图片的左上角获取了一个黑色的点

136
00:05:40,470 --> 00:05:42,240
而如果我走得更再往下一点

137
00:05:42,240 --> 00:05:43,350
比如说... 往下1000个像素

138
00:05:43,350 --> 00:05:45,420
我们就得到了一个蓝色的点

139
00:05:45,420 --> 00:05:47,500
大概是地毯这边的的某个像素的颜色

140
00:05:48,060 --> 00:05:50,580
我们也可以切割这张图片

141
00:05:50,580 --> 00:05:54,270
假设我想获取竖直方向的第1个像素到第1000个像素

142
00:05:54,270 --> 00:05:57,180
水平方向的第1个像素到第400个像素

143
00:05:57,180 --> 00:05:59,280
诸如此类的东西

144
00:05:59,460 --> 00:06:01,710
程序将返回另一个数组

145
00:06:03,390 --> 00:06:06,810
它是一个数组，代表了原始图片的一小块

146
00:06:06,810 --> 00:06:10,650
只是从左上角开始1000*400的一小块图片

147
00:06:10,650 --> 00:06:12,920
和我们在这里看到的相吻合

148
00:06:13,100 --> 00:06:15,830
但这也许是图片中最不有趣的部分

149
00:06:15,830 --> 00:06:17,000
也许我们更想

150
00:06:17,000 --> 00:06:19,280
截取可爱的小柯基犬所在的那块图片

151
00:06:19,280 --> 00:06:22,430
所以在这里有一个我之前写好的代码块，就可以做到这件事

152
00:06:22,430 --> 00:06:24,350
首先我们看一下原图尺寸

153
00:06:24,350 --> 00:06:26,210
即高度和宽度

154
00:06:26,210 --> 00:06:29,240
我写的是 (h,w)=size(philip)

155
00:06:29,450 --> 00:06:30,920
然后我们要获取

156
00:06:30,920 --> 00:06:33,440
数组切割后的结果

157
00:06:33,440 --> 00:06:35,960
这里我截了图像的下半部分

158
00:06:35,960 --> 00:06:36,860
这里我截了图像的下半部分

159
00:06:36,860 --> 00:06:38,260
一直到图片底部

160
00:06:38,440 --> 00:06:39,400
顺便说一句

161
00:06:39,400 --> 00:06:41,410
这里我们用了键盘上找不到的除号

162
00:06:41,410 --> 00:06:42,370
在Julia中

163
00:06:42,370 --> 00:06:46,240
你可以输入Latex语言中的几乎任何符号

164
00:06:46,240 --> 00:06:47,830
只要用反斜杠开头，输入div，然后按Tab键

165
00:06:47,830 --> 00:06:48,850
只要用反斜杠开头，输入div，然后按Tab键

166
00:06:48,850 --> 00:06:51,730
这让我们可以用键盘上没有的符号来写程序

167
00:06:51,730 --> 00:06:54,460
目的是让Julia写出来的代码像数学公式一样易读

168
00:06:54,460 --> 00:06:56,260
因此，如果我输入反斜杠-nabla

169
00:06:56,260 --> 00:06:58,450
就会出现这个倒置的三角形符号

170
00:06:58,510 --> 00:07:00,610
我们不必将其定义为一个变量

171
00:07:00,610 --> 00:07:02,200
就能使用它

172
00:07:02,200 --> 00:07:02,860
不过现在

173
00:07:02,860 --> 00:07:04,300
当我们使用除法符号

174
00:07:04,300 --> 00:07:06,040
我们是在做整除

175
00:07:06,040 --> 00:07:07,750
所以这里是在把高度除以二

176
00:07:07,750 --> 00:07:09,710
并且把结果取到一个接近的整数上

177
00:07:09,960 --> 00:07:11,460
我们就因此获得了这张图片的下半部分

178
00:07:11,460 --> 00:07:15,000
然后宽度上，我们从左起的1/10开始

179
00:07:15,000 --> 00:07:16,680
一直到右边的9/10位置

180
00:07:16,680 --> 00:07:19,260
我们将这个结果定义为head

181
00:07:19,440 --> 00:07:20,730
所以现在如果我们要查询

182
00:07:20,730 --> 00:07:22,370
head的大小是多少

183
00:07:23,800 --> 00:07:25,750
我们可以看到它比原图要小

184
00:07:25,750 --> 00:07:25,990
实际上

185
00:07:25,990 --> 00:07:28,010
如果我们将其与Philip的大小比较

186
00:07:30,390 --> 00:07:32,820
我们看到第一维大约是原来一半

187
00:07:32,820 --> 00:07:34,170
然后第二个维度

188
00:07:34,860 --> 00:07:35,520
应该是原来80％

189
00:07:35,520 --> 00:07:36,860
的确是这样

190
00:07:37,150 --> 00:07:38,230
目前一切顺利

191
00:07:38,230 --> 00:07:41,530
这就是我们对数组进行切片，来获得数组的一小部分的方法

192
00:07:42,100 --> 00:07:45,100
我们可以做的另一件事是将数组连接在一起

193
00:07:45,100 --> 00:07:49,060
因此，如果我输入左括号，head（这是我们之前获取的柯基图片）合

194
00:07:49,060 --> 00:07:49,840
然后空格

195
00:07:49,840 --> 00:07:52,660
然后再输入一次head，然后用右括号闭合

196
00:07:52,660 --> 00:07:55,900
我们得到的是一个将两个head拼在一起的数组

197
00:07:56,080 --> 00:07:59,270
所以如果我用typeof()查询这个东西的类型

198
00:07:59,500 --> 00:08:00,640
结果发现

199
00:08:00,640 --> 00:08:01,570
它和刚才是同一类型

200
00:08:01,570 --> 00:08:04,150
是具有RGB值的数组

201
00:08:04,150 --> 00:08:05,810
如果要知道它的大小

202
00:08:05,990 --> 00:08:07,280
我们会发现它比刚刚要宽得多

203
00:08:07,280 --> 00:08:08,390
大约两倍宽

204
00:08:08,390 --> 00:08:09,820
这符合我们的预期

205
00:08:10,000 --> 00:08:10,420
不过无论如何

206
00:08:10,420 --> 00:08:12,370
这个拼起来的图看起来很棒

207
00:08:12,740 --> 00:08:14,900
我们可以通过拼接来做一些有趣的事情

208
00:08:14,900 --> 00:08:17,420
比如创造一个“柯基万花筒”

209
00:08:17,420 --> 00:08:21,920
我们这里有四个不同的图像拼接起来

210
00:08:21,920 --> 00:08:24,050
我们在左上角是“head”

211
00:08:24,050 --> 00:08:25,400
在右上方

212
00:08:25,400 --> 00:08:25,940
我做的是

213
00:08:26,050 --> 00:08:28,236
把head沿第二维反转

214
00:08:28,342 --> 00:08:30,800
所以如果我像刚刚那样输入head

215
00:08:31,520 --> 00:08:34,020
那右上方的图像就应该和原来一样

216
00:08:34,200 --> 00:08:35,500
但如果我把它反转

217
00:08:36,720 --> 00:08:37,890
输入"reverse(head)"

218
00:08:38,740 --> 00:08:43,310
然后Julia提示说我没有对reverse传入参数

219
00:08:43,490 --> 00:08:45,129
因此我指定维度

220
00:08:45,129 --> 00:08:48,090
在这里要沿第二根轴翻转

221
00:08:48,300 --> 00:08:52,270
那么程序就会沿着垂直方向

222
00:08:52,900 --> 00:08:53,860
翻转head这个图片

223
00:08:53,860 --> 00:08:55,390
然后你也可以看到

224
00:08:55,660 --> 00:08:57,250
左下象限

225
00:08:57,250 --> 00:08:58,510
我们把它其沿另一个方向翻转

226
00:08:58,510 --> 00:09:00,010
而在右下角

227
00:09:00,010 --> 00:09:01,090
我们沿着两根轴一起翻转了

228
00:09:01,090 --> 00:09:02,770
因此，我们就得到了这张很棒的

229
00:09:02,770 --> 00:09:04,660
柯基的多重镜像图片

230
00:09:04,840 --> 00:09:05,770
不过，这里的重点是

231
00:09:05,770 --> 00:09:08,140
拼接数组功能是多么的厉害

232
00:09:08,140 --> 00:09:10,360
并且我们用这个左括号，右括号

233
00:09:10,360 --> 00:09:11,890
然后像在数学公式那样

234
00:09:11,890 --> 00:09:14,110
把变量写在里面

235
00:09:14,110 --> 00:09:15,340
就能够表达矩阵

236
00:09:15,340 --> 00:09:17,110
在不同的位置有不同的元素

237
00:09:17,470 --> 00:09:18,790
现在，我们真正想要的是

238
00:09:18,790 --> 00:09:22,390
对每个像素进行深入操作，并开始做一些有趣的事情

239
00:09:22,570 --> 00:09:24,460
我们可能会尝试两种方式

240
00:09:24,460 --> 00:09:28,060
一种是直接修改数组本身

241
00:09:28,060 --> 00:09:32,500
另一个将是复制数组，创建一个新对象，让它和原来的图片产生不同

242
00:09:32,740 --> 00:09:34,900
Julia中复制东西很简单

243
00:09:34,900 --> 00:09:36,800
我们只是调用函数“copy”

244
00:09:36,980 --> 00:09:39,920
当我声明new_phil，让它等于head的部分

245
00:09:39,920 --> 00:09:42,320
我们就有一个新的变量，代表了新的数据

246
00:09:42,320 --> 00:09:45,020
如果我们开始操作此new_phil变量

247
00:09:45,020 --> 00:09:47,930
它不会更改phil中的原始数据

248
00:09:47,930 --> 00:09:50,300
（phil是new_phil的来源）

249
00:09:50,920 --> 00:09:52,840
所以现在我们要做的

250
00:09:52,840 --> 00:09:55,420
是把图片的某个角落

251
00:09:55,420 --> 00:09:57,370
涂成单一颜色，比如红色

252
00:09:57,550 --> 00:10:00,602
我们可以考虑两种不同的方法

253
00:10:00,626 --> 00:10:03,940
一种是创建一个两层for循环，外层遍历所有i

254
00:10:03,940 --> 00:10:05,850
范围从1到100

255
00:10:06,030 --> 00:10:08,340
然后内存遍历所有j，从1到100

256
00:10:08,340 --> 00:10:11,289
诶，不妨改成一个不同的数字，例如300

257
00:10:11,289 --> 00:10:15,380
这样我们就能更方便地看到哪个下标对应哪个维度

258
00:10:15,630 --> 00:10:16,260
然后在那之后

259
00:10:16,260 --> 00:10:18,120
我将使用这个new_phil数组，

260
00:10:18,120 --> 00:10:20,966
索引到[i，j]

261
00:10:20,966 --> 00:10:23,545
然后让这个像素变成红色

262
00:10:23,545 --> 00:10:26,190
其中红色是前面定义好的

263
00:10:26,190 --> 00:10:29,340
RGB值是(1,0,0)的颜色

264
00:10:30,030 --> 00:10:31,110
现在我们可以看到

265
00:10:31,110 --> 00:10:32,250
不像其他代码块

266
00:10:32,250 --> 00:10:33,716
这个代码块没有输出任何东西

267
00:10:33,866 --> 00:10:36,340
这是因为for循环本身不会返回任何东西

268
00:10:36,340 --> 00:10:38,350
因此我需要重新输入

269
00:10:38,610 --> 00:10:39,150
new_phil

270
00:10:39,150 --> 00:10:43,560
我们将看到new_phil确实已被修改

271
00:10:43,560 --> 00:10:49,230
看起来j变量对应的是沿水平方向

272
00:10:49,410 --> 00:10:50,340
这也很合逻辑

273
00:10:50,340 --> 00:10:53,730
因为我们操作数组时是先从上到下

274
00:10:53,730 --> 00:10:55,950
然后再是从左到右

275
00:10:55,950 --> 00:10:58,632
其实这和那些老式的打印机的方法是一样的

276
00:10:58,632 --> 00:11:00,720
就是那种左到右，左到右的方法

277
00:11:00,720 --> 00:11:02,220
也就像你读书的方式

278
00:11:02,220 --> 00:11:03,270
或其他类似的东西

279
00:11:03,930 --> 00:11:04,680
所以很好

280
00:11:04,680 --> 00:11:05,970
我们已经修改了我们的图片

281
00:11:05,970 --> 00:11:08,781
但是实际上，有一种更简单的方法

282
00:11:08,781 --> 00:11:12,060
可以让我们不用写for循环就改变这些像素

283
00:11:12,260 --> 00:11:14,700
我们可以做所谓的“广播(broadcasting)”

284
00:11:14,980 --> 00:11:18,289
所以在这里我要做的是创建另一个phil, 叫做new_phil2

285
00:11:18,409 --> 00:11:20,364
这是new_phil的一个副本

286
00:11:20,364 --> 00:11:23,530
然后我要对它切片时

287
00:11:23,530 --> 00:11:26,808
从上到下100像素到200像素

288
00:11:26,921 --> 00:11:28,227
所以这其实是

289
00:11:28,227 --> 00:11:30,372
刚刚我涂红的地方的下面的位置

290
00:11:30,519 --> 00:11:32,662
然后从左到右是1到100的像素

291
00:11:32,771 --> 00:11:36,248
是原来的涂红的矩形的三分之一大小

292
00:11:36,372 --> 00:11:37,554
然后输入

293
00:11:37,554 --> 00:11:39,820
点等于(“.=”) RGB (0,1,0)

294
00:11:39,820 --> 00:11:41,620
这是在把这一小块的像素都变成绿色

295
00:11:41,620 --> 00:11:43,330
其他颜色都没有

296
00:11:43,510 --> 00:11:45,910
这里的点表示

297
00:11:45,910 --> 00:11:48,040
你在告诉程序

298
00:11:48,040 --> 00:11:50,530
不要对这个等号左边的这个对象（数组）本身进行操作

299
00:11:50,530 --> 00:11:51,700
不要对这个等号左边的这个对象（数组）本身进行操作

300
00:11:51,700 --> 00:11:52,994
而是要让程序对于数组中的每一个元素一个个进行操作

301
00:11:52,994 --> 00:11:55,615
要是要让程序对于数组中的每一个元素一个个进行操作

302
00:11:56,020 --> 00:11:58,990
因此，这和我们上面的for循环在做同样的事情

303
00:11:58,990 --> 00:12:01,130
但是语法上，它看起来要好得多

304
00:12:01,830 --> 00:12:06,390
实际上，在数组中用“点等于”进行广播的想法在Julia中非常普遍

305
00:12:06,390 --> 00:12:08,160
你还可以把广播和函数结合起来

306
00:12:08,160 --> 00:12:10,740
而不必像这样，做单纯的变量赋值

307
00:12:10,740 --> 00:12:12,380
来，让我们瞧瞧这是怎么做的

308
00:12:13,890 --> 00:12:17,370
假设我写了一个函数，想把它作用在每个像素上

309
00:12:17,370 --> 00:12:18,540
在本例中

310
00:12:18,540 --> 00:12:21,270
我正在定义一个名为“redify”的函数

311
00:12:21,270 --> 00:12:23,490
在“redify”传入一个变量

312
00:12:23,490 --> 00:12:24,480
oh，换个变量名

313
00:12:24,480 --> 00:12:25,990
不如命名为“color”

314
00:12:26,470 --> 00:12:28,160
我们传入一个颜色

315
00:12:28,340 --> 00:12:31,100
然后这个函数会返回一个新的RGB值

316
00:12:31,100 --> 00:12:34,580
这个新颜色只保留了旧颜色中的红色分量（“color.r”）

317
00:12:34,580 --> 00:12:37,370
而丢弃掉了所有蓝色和绿色

318
00:12:37,370 --> 00:12:39,170
所以本质上，这个函数是在把一个像素

319
00:12:39,170 --> 00:12:40,880
去掉它的蓝色和绿色值之后

320
00:12:40,880 --> 00:12:43,500
仅保留其红色值，然后返回

321
00:12:43,680 --> 00:12:45,300
所以，举个栗子

322
00:12:45,300 --> 00:12:49,653
假设我定义了一种RGB值为(0.8,0.5,0.2)的颜色

323
00:12:49,653 --> 00:12:51,509
看起来是个很棒的褐色

324
00:12:51,616 --> 00:12:53,764
也许我们减少一点红色的分量

325
00:12:53,764 --> 00:12:56,170
然后得到这个绿不拉几的颜色

326
00:12:56,430 --> 00:13:03,090
如果我要显示一个列表 [[color, redify(color)]

327
00:13:03,270 --> 00:13:05,100
程序会首先显示原始的颜色

328
00:13:05,100 --> 00:13:07,460
以及颜色在输入redify之后输出出来的颜色

329
00:13:07,640 --> 00:13:11,130
无论输入什么颜色

330
00:13:11,130 --> 00:13:12,550
redify就只是在保留这个颜色中红色的部分

331
00:13:12,730 --> 00:13:13,720
这是个很简单的函数

332
00:13:13,720 --> 00:13:15,640
你不一定会在真正的应用当中用到

333
00:13:15,640 --> 00:13:19,540
但我们这里定义这个函数的原因，是为了展示广播的用法

334
00:13:19,720 --> 00:13:24,090
比如说，我们redify广播后作用在把数组Phillip上

335
00:13:24,270 --> 00:13:26,400
只需要调用“ redify.(philip)”

336
00:13:26,400 --> 00:13:30,300
这就是在把redify作用在整个Philip上

337
00:13:30,480 --> 00:13:31,470
所以如果我不写这个点

338
00:13:31,470 --> 00:13:33,060
如果我只是调用“ redify(philip)”

339
00:13:33,060 --> 00:13:34,470
程序会报错：

340
00:13:34,470 --> 00:13:36,600
“Array类型没有字段r”

341
00:13:36,600 --> 00:13:40,580
报错的原因是当redify函数被调用时

342
00:13:40,580 --> 00:13:42,050
它认为参数color是一个颜色

343
00:13:42,050 --> 00:13:44,270
然后试图获取参数color的分量r

344
00:13:44,270 --> 00:13:47,581
默认输入参数的类型是正确的

345
00:13:47,581 --> 00:13:50,867
但事实并非如此，因此程序报错了

346
00:13:50,867 --> 00:13:51,350
当然

347
00:13:51,350 --> 00:13:53,720
如果我们在philip的所有像素之间广播

348
00:13:53,720 --> 00:13:54,740
那就是正确的类型

349
00:13:54,740 --> 00:13:56,510
调用之后可以看到
这张照片

350
00:13:56,510 --> 00:13:59,600
就有点像是在老式的胶卷房里

351
00:13:59,600 --> 00:14:03,720
晾绳上面悬挂着的一张在显影的柯基照片

352
00:14:03,900 --> 00:14:04,830
看到这里，我建议你

353
00:14:04,830 --> 00:14:07,565
你可以自己试着写一个

354
00:14:07,565 --> 00:14:09,142
把颜色做些变换的函数

355
00:14:09,142 --> 00:14:12,050
然后通过广播的方式作用在你喜欢的任何一张图像上

356
00:14:12,050 --> 00:14:15,280
注意，如果作用在很大的图片上，这个操作可能会有点慢

357
00:14:15,280 --> 00:14:17,529
因此，如果你只是想快速的试试看你程序写的对不对

358
00:14:17,637 --> 00:14:21,040
一种不错的策略是使用采样功能

359
00:14:21,040 --> 00:14:22,960
如果我们对数组使用decimate函数

360
00:14:22,960 --> 00:14:24,490
程序会把这个数组缩成一个更小的数组

361
00:14:24,490 --> 00:14:25,750
在这

362
00:14:25,750 --> 00:14:27,670
程序会把每5个元素保留一个

363
00:14:27,670 --> 00:14:29,738
不过我们也可以10个保留一个

364
00:14:29,738 --> 00:14:31,550
就像这样

365
00:14:31,550 --> 00:14:35,332
或者，还可以每两个保留一个

366
00:14:35,332 --> 00:14:37,460
当然图片质量会下降

367
00:14:37,460 --> 00:14:39,200
就图像压缩而言

368
00:14:39,200 --> 00:14:41,180
这个方法不是很复杂，

369
00:14:41,180 --> 00:14:46,310
但是也不错，可以把原图缩成一张看起来差不多的小图片

370
00:14:46,310 --> 00:14:47,060
但当然

371
00:14:47,060 --> 00:14:48,350
图像的分辨率就很低了

372
00:14:48,530 --> 00:14:50,000
所以如果我们想要知道

373
00:14:50,000 --> 00:14:54,400
这个新变量定义的poor_phil的大小是多少

374
00:14:54,780 --> 00:14:57,250
我们看到它明显较小

375
00:14:57,430 --> 00:14:58,570
所以，如果我们想要一个

376
00:14:58,570 --> 00:15:00,130
不错的小图片，以便快速使用

377
00:15:00,130 --> 00:15:01,420
我们可以叫它“poor_phil”

378
00:15:01,420 --> 00:15:03,800
不错哦

379
00:15:03,800 --> 00:15:04,550
例如

380
00:15:04,550 --> 00:15:07,490
我们可以做些很厉害的事情。虽然这主要是第二讲的内容

381
00:15:07,490 --> 00:15:09,350
但是我们今天可以先管中窥豹

382
00:15:09,350 --> 00:15:12,170
那就是卷积

383
00:15:12,170 --> 00:15:14,150
这在图像处理中很常见

384
00:15:14,150 --> 00:15:16,755
这是一种我们可以遍历每个像素

385
00:15:16,779 --> 00:15:19,430
并根据该像素周围的几个像素，来对其进行操作的方法

386
00:15:19,430 --> 00:15:22,460
再次提醒，我们会在下一节课里详细讲这个内容

387
00:15:22,460 --> 00:15:24,410
不过不妨碍我们在这边先预览一下

388
00:15:24,410 --> 00:15:26,540
我正在调用一个称为卷积的函数

389
00:15:26,540 --> 00:15:27,950
输入参数“poor_phil”

390
00:15:27,950 --> 00:15:30,620
就是我们刚刚采样得到的小狗头

391
00:15:30,800 --> 00:15:34,040
然后第二个参数传入blur(2)

392
00:15:34,040 --> 00:15:35,390
如果你想知道“blur(2)”是什么

393
00:15:35,390 --> 00:15:37,020
我们可以直接把它打印出来看看

394
00:15:37,200 --> 00:15:40,080
可以看到，它是一个2x2的浮点数组

395
00:15:40,080 --> 00:15:41,670
有预先设置好的值

396
00:15:41,670 --> 00:15:43,860
如果听了我们在下一讲中讨论的内容

397
00:15:43,860 --> 00:15:47,930
你也许会更清楚这个数组是干什么的

398
00:15:48,210 --> 00:15:53,400
但是如果我调用这个卷积函数，传入这个数组和blur(2)，结果是让这个图片更加模糊一点

399
00:15:53,400 --> 00:15:54,630
但还是比较清楚地

400
00:15:54,630 --> 00:15:57,420
如果我传一个模糊值更大的参数，比如说10

401
00:15:58,020 --> 00:16:00,640
可以用同样的方法查看blur(10)的值

402
00:16:02,940 --> 00:16:05,160
这是一个更大一点的数组

403
00:16:05,160 --> 00:16:07,040
有另外一组预先设置好的值

404
00:16:07,220 --> 00:16:10,373
你现在可能已经可以猜出这个东西是用来干嘛的了

405
00:16:10,397 --> 00:16:13,550
它是在取特定像素周围所有像素的平均值

406
00:16:13,550 --> 00:16:15,440
通过取平均值

407
00:16:15,440 --> 00:16:18,340
使图片看起来有虚焦的效果

408
00:16:18,340 --> 00:16:20,080
所以如果只有blur(1)

409
00:16:20,080 --> 00:16:22,570
结果实际上就是原始图像

410
00:16:22,570 --> 00:16:26,760
但是，当这个blur值增加时，图片会变得越来越模糊

411
00:16:27,050 --> 00:16:28,370
注意，让我们在调试观察时

412
00:16:28,370 --> 00:16:29,630
如果需要修改这个变量的话

413
00:16:29,630 --> 00:16:30,740
需要一次次的输入不同的值

414
00:16:30,740 --> 00:16:33,290
不过在Pluto中

415
00:16:33,290 --> 00:16:35,000
其实我们有更好的办法来调试

416
00:16:35,000 --> 00:16:38,200
我们可以使用UI（User Interface, 用户界面）元素

417
00:16:38,380 --> 00:16:40,885
我们可以导入PlutoUI这个库

418
00:16:41,012 --> 00:16:43,930
然后，比如说，创建一个滑块

419
00:16:44,110 --> 00:16:50,020
然后将一个名为blur_factor的变量绑定到滑块

420
00:16:50,020 --> 00:16:52,060
滑块的值将介于1到20之间

421
00:16:52,060 --> 00:16:54,310
同时在屏幕上实时显示这个值

422
00:16:54,428 --> 00:16:55,948
像现在这个值就是1

423
00:16:55,948 --> 00:16:57,400
而如果我操作一下

424
00:16:57,400 --> 00:16:59,180
它就会显示了另一个值

425
00:16:59,360 --> 00:17:01,340
现在我们可以使用该变量

426
00:17:01,340 --> 00:17:02,810
就用和之前演示中一样的代码

427
00:17:02,810 --> 00:17:07,190
也就是对poor_phil用blur核进行卷积

428
00:17:07,190 --> 00:17:09,440
blur的参数是我输入的数字

429
00:17:09,440 --> 00:17:11,780
但现在就可以通过人机交互的方式进行

430
00:17:11,780 --> 00:17:13,320
很不错吧

431
00:17:13,320 --> 00:17:14,640
如果你正在探索某个程序的效果

432
00:17:14,640 --> 00:17:18,403
那么用这种方法调整变量是个不错的主意

433
00:17:18,427 --> 00:17:22,201
它可以让你用来熟悉任何一个你想了解的函数的功能

434
00:17:22,201 --> 00:17:24,224
所以现在

435
00:17:24,224 --> 00:17:26,040
任何观看此影片的人都可以想一想

436
00:17:26,040 --> 00:17:28,890
我建议你考虑一下blur是做什么用的

437
00:17:28,890 --> 00:17:30,240
就像我说的

438
00:17:30,240 --> 00:17:33,630
它将处理图片的每一个像素，并根据周围的邻近的像素对其进行修改

439
00:17:33,630 --> 00:17:34,710
这个大概的意思

440
00:17:34,710 --> 00:17:36,810
可以像这样用伪代码表达：

441
00:17:36,810 --> 00:17:40,710
对于图像的每个元素（下标[i, j]）

442
00:17:40,710 --> 00:17:43,230
函数的结果是由其相邻的一些元素决定的

443
00:17:43,230 --> 00:17:45,270
这是个很强大的工具

444
00:17:45,270 --> 00:17:49,050
如果这个函数只是一个平均数或更复杂的平均数

445
00:17:49,050 --> 00:17:50,730
通常会产生模糊效果

446
00:17:50,730 --> 00:17:52,200
但是我们可以用它做更智能的事情

447
00:17:52,200 --> 00:17:54,360
您要在第一次作业中要做的一件事

448
00:17:54,360 --> 00:17:58,395
就是要试着通过某个像素的信息

449
00:17:58,395 --> 00:18:00,034
加上周围像素们的信息

450
00:18:00,034 --> 00:18:01,602
来检测这个图像的边缘在哪里

451
00:18:01,602 --> 00:18:04,111
来检测这个图像的边缘在哪里

452
00:18:05,784 --> 00:18:07,090
所以在这种情况下

453
00:18:07,090 --> 00:18:11,580
最终的效果就大概是，调用一个你自己写的函数，比如叫edge_detect

454
00:18:12,100 --> 00:18:16,100
作用在“poor_phil”上

455
00:18:16,100 --> 00:18:18,140
它画出了很多小边缘

456
00:18:18,140 --> 00:18:20,240
然后我们可以再深入研究一下

457
00:18:20,240 --> 00:18:22,280
要是我先做一次平滑（即模糊）操作

458
00:18:22,280 --> 00:18:23,870
之后再进行边缘检测

459
00:18:23,870 --> 00:18:25,990
我可以使用卷积，convolve(poor_phil)

460
00:18:26,210 --> 00:18:29,230
比如说是模糊因子3

461
00:18:30,070 --> 00:18:33,270
oh程序出错了，报错显示是语法错误

462
00:18:33,620 --> 00:18:34,940
emm （小哥debug中）

463
00:18:34,940 --> 00:18:37,860
emm （小哥debug中）

464
00:18:38,620 --> 00:18:39,820
emm （小哥debug中）

465
00:18:40,000 --> 00:18:43,110
（仍然debug中）

466
00:18:43,290 --> 00:18:47,170
...哦，我只是括号没补全...OK了

467
00:18:48,480 --> 00:18:49,710
如果我用了一个平滑后的图片

468
00:18:49,710 --> 00:18:50,970
程序将只会检测到更少的边缘

469
00:18:50,970 --> 00:18:52,020
这很合理

470
00:18:52,020 --> 00:18:54,030
因为一个图片越平滑

471
00:18:54,030 --> 00:18:55,760
找到的边缘就越少

472
00:18:56,140 --> 00:19:00,550
不过这些都是我们在下一节课当中要仔细讲的事情了

473
00:19:00,770 --> 00:19:01,490
在那之前

474
00:19:01,490 --> 00:19:04,070
我希望你开始思考，这东西是怎么实现的呢？

475
00:19:04,370 --> 00:19:06,800
什么是边缘？如何检测边缘？

476
00:19:06,800 --> 00:19:08,570
特别是，如果在很杂乱的画面中

477
00:19:08,570 --> 00:19:10,630
我们该怎么做才能克服图片中的干扰?

478
00:19:10,810 --> 00:19:11,080
再次提示

479
00:19:11,080 --> 00:19:14,560
边缘检测在许多科学应用中非常有用

480
00:19:14,560 --> 00:19:16,330
比如，你拍了一堆细胞的照片

481
00:19:16,330 --> 00:19:18,370
你想知道那里有多少个细胞

482
00:19:18,370 --> 00:19:20,590
但你不想自己数，想让计算机自动帮你数

483
00:19:20,590 --> 00:19:22,930
那一个经典解法就是从检测边缘开始

484
00:19:22,930 --> 00:19:24,520
把原始照片转换为一个更简单的图片

485
00:19:25,470 --> 00:19:26,520
随着课程的深入

486
00:19:26,520 --> 00:19:29,220
我们将开始用这些做一些更复杂的事情

487
00:19:29,220 --> 00:19:30,690
程序也会越来越酷炫

488
00:19:30,690 --> 00:19:32,590
你也会越来越享受这个过程

